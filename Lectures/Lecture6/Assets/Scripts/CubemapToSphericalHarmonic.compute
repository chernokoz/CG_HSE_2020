// Each #kernel tells which function to compile; you can have many kernels
// ReSharper disable CppInconsistentNaming
#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 25000;
    
    // See SH.shader for more details

    // Populate results buffer using monte-carlo method.
    // You can see the Random(i) function. Use it just as with the previous task.

    int n = SAMPLES;

    float alpha;
    float cosTheta;
    float sinTheta;
    float3 local_direction;
    float3 direction;

    float3 L_0_0_sum;
    float3 L_1_min1_sum;
    float3 L_1_0_sum;
    float3 L_1_1_sum;
    float3 L_2_min2_sum;
    float3 L_2_min1_sum;
    float3 L_2_0_sum;
    float3 L_2_1_sum;
    float3 L_2_2_sum;

    for (int i = 0; i < n; i++)
    {
        alpha = Random(i) * 2 * PI;
        cosTheta = -1 + Random(i + n) * 2;
        sinTheta = sqrt(1 - cosTheta * cosTheta);
        local_direction.x = sinTheta * cos(alpha);
        local_direction.y = cosTheta;
        local_direction.z = sinTheta * sin(alpha);
        direction = normalize(float3(local_direction.x, local_direction.y, local_direction.z));
        
        L_0_0_sum += SampleColor(direction);
        L_1_min1_sum += SampleColor(direction) * direction.y;
        L_1_0_sum += SampleColor(direction) * direction.z;
        L_1_1_sum += SampleColor(direction) * direction.x;
        L_2_min2_sum += SampleColor(direction) * direction.x * direction.y;
        L_2_min1_sum += SampleColor(direction) * direction.y * direction.z;
        L_2_0_sum += SampleColor(direction) * (3 * direction.z * direction.z - 1);
        L_2_1_sum += SampleColor(direction) * direction.x * direction.z;
        L_2_2_sum += SampleColor(direction) * (direction.x * direction.x - direction.y - direction.y);
        
    }

    float area = FOUR_PI * 1 * 1;

    // Zero stage
    // L_0_0_sum = L_0_0_sum / n * INV_PI * 0.5 * sqrt(INV_PI) * area * (0.5 * sqrt(INV_PI) * (PI));
    // L_1_min1_sum = L_1_min1_sum / n * INV_PI * (- 0.5 * sqrt(3 * INV_PI)) * area * (- 0.5 * sqrt(3 * INV_PI) * (TWO_PI / 3));
    // L_1_0_sum = L_1_0_sum / n * INV_PI * (0.5 * sqrt(3 * INV_PI)) * area * (0.5 * sqrt(3 * INV_PI) * (TWO_PI / 3));
    // L_1_1_sum = L_1_1_sum / n * INV_PI * (- 0.5 * sqrt(3 * INV_PI)) * area * (- 0.5 * sqrt(3 * INV_PI) * (TWO_PI / 3));
    // L_2_min2_sum = L_2_min2_sum / n * INV_PI * (0.5 * sqrt(15 * INV_PI)) * area * (0.5 * sqrt(15 * INV_PI) * (PI / 4));
    // L_2_min1_sum = L_2_min1_sum / n * INV_PI * (- 0.5 * sqrt(15 * INV_PI)) * area * (- 0.5 * sqrt(15 * INV_PI) * (PI / 4));
    // L_2_0_sum = L_2_0_sum / n * INV_PI * (0.25 * sqrt(5 * INV_PI)) * area * (0.25 * sqrt(5 * INV_PI) * (PI / 4)) * 2; // (* 2) because 0.5 is already on shader
    // L_2_1_sum = L_2_1_sum / n * INV_PI * (- 0.5 * sqrt(15 * INV_PI)) * area * (- 0.5 * sqrt(15 * INV_PI) * (PI / 4));
    // L_2_2_sum = L_2_2_sum / n * INV_PI * (0.25 * sqrt(15 * INV_PI)) * area * (0.25 * sqrt(15 * INV_PI) * (PI / 4));

    // First stage
    // L_0_0_sum = L_0_0_sum / n * INV_PI * (0.25 * INV_PI) * area * (PI);
    // L_1_min1_sum = L_1_min1_sum / n * INV_PI * (0.25 * 3 * INV_PI) * area (TWO_PI / 3);
    // L_1_0_sum = L_1_0_sum / n * INV_PI * (0.25 * 3 * INV_PI) * area * (TWO_PI / 3);
    // L_1_1_sum = L_1_1_sum / n * INV_PI * (0.25 * 3 * INV_PI) * area * (TWO_PI / 3);
    // L_2_min2_sum = L_2_min2_sum / n * INV_PI * (0.25 * 15 * INV_PI) * area * (PI / 4);
    // L_2_min1_sum = L_2_min1_sum / n * INV_PI * (0.25 * 15 * INV_PI) * area * (PI / 4) ;
    // L_2_0_sum = L_2_0_sum / n * INV_PI * (1 / 16 * 5 * INV_PI) * area * (PI / 4) * 2;
    // L_2_1_sum = L_2_1_sum / n * INV_PI * (0.25 * 15 * INV_PI) * area * (PI / 4);
    // L_2_2_sum = L_2_2_sum / n * INV_PI * (1 / 16 * 15 * INV_PI) * area * (PI / 4);

    // Second stage
    L_0_0_sum = L_0_0_sum / n;
    L_1_min1_sum = L_1_min1_sum / n * 2;
    L_1_0_sum = L_1_0_sum / n * 2;
    L_1_1_sum = L_1_1_sum / n * 2;
    L_2_min2_sum = L_2_min2_sum / n * 15 / 4;
    L_2_min1_sum = L_2_min1_sum / n * 15 / 4;
    L_2_0_sum = L_2_0_sum / n  * 5 / 8;
    L_2_1_sum = L_2_1_sum / n * 15 / 4;
    L_2_2_sum = L_2_2_sum / n * 15 / 16;
    
    float4 results[7] = {
        float4(L_1_1_sum.x, L_1_min1_sum.x, L_1_0_sum.x, L_0_0_sum.x), // SH_0_1_r
        float4(L_1_1_sum.y, L_1_min1_sum.y, L_1_0_sum.y, L_0_0_sum.y), // SH_0_1_g
        float4(L_1_1_sum.z, L_1_min1_sum.z, L_1_0_sum.z, L_0_0_sum.z), // SH_0_1_b
        
        float4(L_2_min2_sum.x, L_2_min1_sum.x, L_2_1_sum.x, L_2_0_sum.x), // SH_2_r
        float4(L_2_min2_sum.y, L_2_min1_sum.y, L_2_1_sum.y, L_2_0_sum.y), // SH_2_g
        float4(L_2_min2_sum.z, L_2_min1_sum.z, L_2_1_sum.z, L_2_0_sum.z), // SH_2_b
        
        float4(L_2_2_sum.x, L_2_2_sum.y, L_2_2_sum.z, 0), // SH_2_rgb
    };

    // TASK: project light from _Env to spherical harmonic coefficients and store them in results[]
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
    
    SH_2_rgb[id] = results[6];
}

/*
float4 results[7] = {
    float4(0.0036f, 0.0526f, -0.0017f, 0.2530f),
    float4(0.0020f, 0.2076f,  0.0093f, 0.3641f),
    float4(0.0024f, 0.0501f, -0.0076f, 0.0042f),
    float4(0.0025f, 0.0519f, -0.0046f, 0.0082f),
    float4(0.0016f, 0.1011f,  0.0048f, 0.3180f),
    float4(0.0031f, 0.0584f, -0.0035f, 0.0068f),
    float4(0.0001f, 0.0002f,  0.0001f, 0.0000f),
    };
*/